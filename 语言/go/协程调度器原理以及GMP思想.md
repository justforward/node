面对之前调度器的问题，Go设计了新的调度器。

在新调度器中，除了M(thread)和G(goroutine)，又引进了P(Processor)。

![[Pasted image 20221226170751.png]]

Processor，它包含了运行goroutine的资源，如果线程想运行goroutine，必须先获取P，P中还包含了可运行的G队列。


### (1) GMP模型

在Go中，**线程是运行goroutine的实体，调度器的功能是把可运行的goroutine分配到工作线程上**。

![[Pasted image 20221226170940.png]]


1.  **全局队列**（Global Queue）：存放等待运行的G。
2.  **P的本地队列**：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G'时，G'优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。
3.  **P列表**：所有的P都在程序启动时创建，并保存在数组中，最多有`GOMAXPROCS`(可配置)个。
4.  **M**：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列**拿**一批G放到P的本地队列，或从其他P的本地队列**偷**一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。


Goroutine调度器和OS调度器是通过M结合在一起的，每个M都代表了1个内核线程，os调度器负责把内核线程分配到CPU的核上执行。

**关于P和M的个数问题**

1、P的数量

由启动的环境变量 $GOMAXPROCS 或者是由runtime的方法GOMAXPROCS()
(设置可同时使用的cpu个数)决定。这意味着在程序执行的任意时刻只有 $GOMAXPROCS个Goroutine正在同时执行。

2、M的数量

go语言本身的限制：go程序启动时候，会设置M的最大数量，默认10000，但是内核很难支持这么多的线程数，所以这个限制可以忽略。

runtime/debug 中
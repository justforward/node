
鸭子类型，是动态编程语言的一种对象推断策略，它更关注对象如何被使用，而不是对象的类型本身。


# Go语言与鸭子类型的关系

**静态语言和动态语言的对比**


静态语言：java C++只能发，必须要显示地声明实现了某个接口，之后， 才能用在任何需要这个接口的地方。

Go语言既有动态语言的便利，同时又会进行静态语言的类型检查。不要求类型显示地声明实现了某个接口，只要实现了相关的方法即可，编译器就能检测到。

顺带再提一下动态语言的特点：

> 变量绑定的类型是不确定的，在运行期间才能确定 函数和方法可以接收任何类型的参数，且调用时不检查参数类型 不需要实现接口


# 值接受者和指针接收者的区别

## 方法

方法能给用户自定义的类型添加新的行为。它和函数的区别在于方法有一个接收者，给一个函数添加一个接受者，它就变成了方法。接受者可以是值接受者，也可以是指针接受者。

在调用方法的时候，值类型既可以调用值接受者的方法，也可以调用指针接受者的方法；指针类型既可以调用`指针接收者`的方法，也可以调用`值接收者`的方法。

也就是说，不管方法的接收者是什么类型，该类型的值和指针都可以调用，不必严格符合接收者的类型。

实际上，当类型和方法的接受者类型不同时，其实是编译器在备受做了一些工作，

![[Pasted image 20230108170014.png]]


# 值接收者和指针接收者


前面说过，不管接受者类型是值类型还是指针类型，都可以通过值类型或者指针类型调用，这里面实际上通过语法糖起作用的。

先说结论：实现了接受者是值类型的方法，相当于自动实现了接受者是指针类型的方法，而实现了接受者是指针类型的方法，不会自动生成对应接受者是值类型的方法。


## 两者分别在何时使用

如果方法的接收者是值类型，无论调用者是对象还是对象指针，修改的都是对象的副本，不影响调用者;如果方法的接收者是指针类型，则调用者修改的是指针指向的对象本身。

使用指针作为方法的接收者的理由：

•方法能够修改接收者指向的值。

•避免在每次调用方法时复制该值，在值的类型为大型结构体时，这样做会更加高效。


如果类型具备“原始的本质”，也就是说他的成员都是由Go语言内置的原始类型，如字符串、整型值等，那就定义值接收者类型的方法，像内置的引用类型，如 slice map interface channel 这些类型比较特殊，声明他们的时候，实际上是创建了一个header，对于他们也是直接定义值接收者类型的方法，这样，调用函数的时候，是直接copy了这些类型的header，而header本身就是为了复制设计的。
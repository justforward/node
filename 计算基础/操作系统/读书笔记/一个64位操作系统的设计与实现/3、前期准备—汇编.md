# 汇编语言

书写格式分为两类：一种是AT&T汇编语言格式、一种是Intel汇编语言格式。
intel汇编语言支持的编译器有MASM编译器、NASM编译器和YASM编译器。
AT&T 汇编语言，支持的编译器是GUN的GAS编译器。

![[Pasted image 20230221195033.png]]

# AT&T 汇编语言与Intel汇编语言格式
![[Pasted image 20230222170546.png]]
![[Pasted image 20230222170603.png]]



# GUN C 内嵌汇编语言

在很多操作系统的开发场景中，C语言依然无法完全替换汇编语言，比如 操作某些也是的CPU寄存器、操作主板上的某些IO端口，或者对性能极为苛刻的场景等。

GUN C语言提供了关键字asm来声明代码是内嵌的汇编语言，
```
#define nop() _asm_ _volatile_ (*nop \n\t*)
// _asm_ 关键字：用于声明这行代码是一个内嵌汇编表达式
//_volatile_ 关键字：告诉编译器这行代码不能被编译器优化。
```


GNU C 语言的内嵌汇编表达式并非像nop函数一般简单，它有着极为复杂的书写格式、
接下来将书写格式分为内嵌汇编表达式、操作约束和修饰符、序号占位符三个部分进行讲解。

1、内嵌汇编表达式

在C语言中嵌入汇编代码需要进行一番准备工作，嵌入前的准备工作主要负责明确寄存器的分配情况，与C语言的融合情况。这些需要在内嵌的汇编表达式中显示标明出来。

内嵌汇编表达式由4部分组成，指令部分:输出部分:输入部分:损坏部分。

指令部分是必填项，当指令表达式存在多条汇编代码时，可全部书写在一对双引号中 使用 ; \n  \t进行分割， 当汇编代码引用寄存器时候，必须在寄存器前面在加一个%符，以表示对寄存器的引用，比如```

```
mov1 $0x10,%%eax
```

输出部分：格式为：输出操作约束（输出表达式），输出操作约束，（输出表达式），。。。。 格式中的输出操作约束和输出表达式成对出现。每条信息之间必须通过逗号"," 分隔开。


损坏部分：描述了在指令部分执行的过程中，将被修改的寄存器、内存空间或者标志寄存器，并且这些修改部分并未在输出部分和输入部分出现过

寄存器修改通知和内存修改通知、标志寄存器修改通知

标志寄存器的作用
-   用来存储相关指令的某些执行结果；
-   用来为 CPU 执行相关指令提供行为依据；
-   用来控制 CPU 的相关工作方式。


## 操作约束和修饰符

每个输入/输出表达式都必须指定本身的操作越苏，操作约束的类型可以细分为寄存器约束、内存越苏和立即数约束，在输出表达式里面还有 限定寄存器操作的越苏符

![[Pasted image 20230222172957.png]]


四种通用寄存器是AX、BX、CX和DX寄存器。
AX —累加器，首选用于大多数操作。
BX—基寄存器，通常用来保存一个过程或变量的地址。
CX—计数寄存器，通常用于循环。
DX—数据寄存器，通常用于乘法和除法。



CPU包含四个段寄存器，用作程序指令的基本位置，
数据，或者堆栈。事实上，IBM PC上对内存的所有引用都涉及一个段
注册为基本位置。
这些寄存器是:
CS-代码段，程序代码的基本位置 code segment
DS -数据段，变量的基本位置 data segment
SS -堆叠段。堆栈的基本位置 stack segment
ES -额外段。内存中变量的附加基位置。 external segment

BP—SS寄存器的偏移量，用于在堆栈上定位变量
SP —栈指针，从SS寄存器到堆栈顶部位置的偏移量


索引寄存器
SI -源索引，用于复制字符串，段寄存器不同
DI -目的索引，用于复制字符串的目的

IP 指令指针寄存器

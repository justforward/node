
# 虚拟内存

https://blog.csdn.net/jinking01/article/details/107098437

尽管基址寄存器和界限寄存器可以用于创建地址空间的抽象，但有些程序运行往往大到内存无法容纳。毕竟目前电脑使用的16G内存算是比较大的空间。

这里引入虚拟内存的概念：

### 虚拟内存基本思想

1）地址空间分割：每个程序都拥有自己的地址空间，这个空间被分割成多个块，每一个块称为一页或者页面。

2）每个页都有连续的地址范围，这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。

3）当程序引用到一部分在物理内存中的地址空间时，由硬件立刻执行必要的映射。当这部分不在物理内存中，由操作系统负责将缺失的部分装入到物理内存并重新执行失败的指令。

虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中，当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。


### 分页

大部分虚拟内存系统都使用一种分页技术。

由程序产生的这些地址称为虚拟地址，他们构成了一个虚拟地址空间，在使用虚拟内存的情况下，虚拟地址不是被直接送到内存总线上，而是被送到内存管理单元(MMU),MMU把虚拟地址映射为物理内存地址，


## 分段

## 段页式管理

段页式内存管理实现的方式：

-   先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制；
-   接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页

为了在多进程环境下，使得进程之间的内存地址不受影响，相互隔离，于是操作系统就为每个进程独立分配一套**虚拟地址空间**，每个程序只关心自己的虚拟地址就可以，实际上大家的虚拟地址都是一样的，但分布到物理地址内存是不一样的。作为程序，也不用关心物理地址的事情。

每个进程都有自己的虚拟空间，而物理内存只有一个，所以当启用了大量的进程，物理内存必然会很紧张，于是操作系统会通过**内存交换**技术，把不常使用的内存暂时存放到硬盘（换出），在需要的时候再装载回物理内存（换入）。

那既然有了虚拟地址空间，那必然要把虚拟地址「映射」到物理地址，这个事情通常由操作系统来维护。

那么对于虚拟地址与物理地址的映射关系，可以有**分段**和**分页**的方式，同时两者结合都是可以的。

内存分段是根据程序的逻辑角度，分成了栈段、堆段、数据段、代码段等，这样可以分离出不同属性的段，同时是一块连续的空间。但是每个段的大小都不是统一的，这就会导致内存碎片和内存交换效率低的问题。

于是，就出现了内存分页，把虚拟空间和物理空间分成大小固定的页，如在 Linux 系统中，每一页的大小为 `4KB`。由于分了页后，就不会产生细小的内存碎片。同时在内存交换的时候，写入硬盘也就一个页或几个页，这就大大提高了内存交换的效率。

再来，为了解决简单分页产生的页表过大的问题，就有了**多级页表**，它解决了空间上的问题，但这就会导致 CPU 在寻址的过程中，需要有很多层表参与，加大了时间上的开销。于是根据程序的**局部性原理**，在 CPU 芯片中加入了 **TLB**，负责缓存最近常被访问的页表项，大大提高了地址的转换速度。

**Linux 系统主要采用了分页管理，但是由于 Intel 处理器的发展史，Linux 系统无法避免分段管理**。于是 Linux 就把所有段的基地址设为 `0`，也就意味着所有程序的地址空间都是线性地址空间（虚拟地址），相当于屏蔽了 CPU 逻辑地址的概念，所以段只被用于访问控制和内存保护。

另外，Linxu 系统中虚拟空间分布可分为**用户态**和**内核态**两部分，其中用户态的分布：代码段、全局变量、BSS、函数栈、堆内存、映射区。


# 应用程序的组成


每个linux进程都有一个地址空间，逻辑上由三段组成：代码、数据、和堆栈段。

1、站在汇编语言角度，从逻辑上讲包括：
程序段
数据段
堆栈段
扩展段

2、站高级语言角度在C语言上，可以包括
程序段
数据段
BSS段
堆
栈

一般我们看到的可执行文件包含，程序段 数据段和BSS段

一般情况下，一个可执行二进制程序（在 linux 下为一个进程单元），在存储时（**没有加载到内存运行**），至少拥有三个部分，分别是代码段(text)、数据段(data)、和BSS 段。

这三个部分一起组成了可执行程序（可能还有其他的段，和平台相关）

当应用程序运行时（**运行态**），此时需要另外两个域：堆和栈。正在运行的程序：**代码段 + 数据段 + BSS 段 + 堆 + 栈**。

如图所示为可执行应用程序**存储态**和**运行态**的结构对照图。一个正在运行的 C 程序占用的内存区域分为代码段、数据段（初始化数据）、BSS 段（未初始化数据）、堆和栈 5 部分

![[Pasted image 20230102191229.png]]

图上的堆箭头，指的是地址分配的方向。

## 内存管理

将应用程序加载到内存空间执行时，操作系统负责代码段、程序段和BSS段的加载，并在内存中为这些进行分配空间。栈也由操作系统管理，不需要程序员显示的管理；堆段需要程序员自己管理，显示的申请和释放。

### 各段说明

#### 代码段

代码段在内存中被映射为只读。它是由编译器在编译链接时自动计算的。通常是用来存放程序执行的指令。代码段输入静态内存分配。

#### 数据段

通常用来存放程序中已初始化的（非 0）全局变量和静态局部变量。数据段的起始位置由链接定位文件确认，大小在编译链接时自动分配。数据段属于静态内存分配

#### BSS段

通常用来存放程序中未初始化和初始化为 0的全局变量的一块内存区域，在程序载入时由内核清零。数据段属于静态内存分配

#### 堆

堆保存函数的内部动态分配（malloc或new的内存），是一种用来保存程序信息的数据结构

堆是先进先出的数据结构，堆的地址是向上增加的，即当堆上保存的数据越多，堆的地址越高。动态内存分配。---每次低位的地址先被读取？


注意：堆内存需要程序员手动管理内存，通常适用于较大的内存分配，如频繁的分配较小的内存，容易导致内存碎片化。



#### 栈

栈保存函数的局部变量（不包含static修饰的变量），参数以及返回值，是一种先进后出的数据结构

在调用函数或者过程后，系统会清除栈上保存的局部变量、函数调用信息以及其他信息


栈的另外一个重要特征是，它的地址空间 向下减少，即当栈上保存的数据越多，栈的地址越低。静态内存分配

注意，由于栈的空间通常比较小，一般 linux 程序只有几 M，故局部变量，函数入参应该避免出现超大栈内存使用，比如超大结构体，数组等，避免出现 stack overflow



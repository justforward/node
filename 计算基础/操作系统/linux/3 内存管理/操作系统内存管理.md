
# 虚拟内存

尽管基址寄存器和界限寄存器可以用于创建地址空间的抽象，但有些程序运行往往大到内存无法容纳。毕竟目前电脑使用的16G内存算是比较大的空间。

这里引入虚拟内存的概念：

### 虚拟内存基本思想

1）地址空间分割：每个程序都拥有自己的地址空间，这个空间被分割成多个块，每一个块称为一页或者页面。

2）每个页都有连续的地址范围，这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。

3）当程序引用到一部分在物理内存中的地址空间时，由硬件立刻执行必要的映射。当这部分不在物理内存中，由操作系统负责将缺失的部分装入到物理内存并重新执行失败的指令。

虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中，当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。


### 分页

大部分虚拟内存系统都使用一种分页技术。

由程序产生的这些地址称为虚拟地址，他们构成了一个虚拟地址空间，在使用虚拟内存的情况下，虚拟地址不是被直接送到内存总线上，而是被送到内存管理单元(MMU),MMU把虚拟地址映射为物理内存地址，





# 应用程序的组成


每个linux进程都有一个地址空间，逻辑上由三段组成：代码、数据、和堆栈段。

1、站在汇编语言角度，从逻辑上讲包括：
程序段
数据段
堆栈段
扩展段

2、站高级语言角度在C语言上，可以包括
程序段
数据段
BSS段
堆
栈

一般我们看到的可执行文件包含，程序段 数据段和BSS段

一般情况下，一个可执行二进制程序（在 linux 下为一个进程单元），在存储时（**没有加载到内存运行**），至少拥有三个部分，分别是代码段(text)、数据段(data)、和BSS 段。

这三个部分一起组成了可执行程序（可能还有其他的段，和平台相关）

当应用程序运行时（**运行态**），此时需要另外两个域：堆和栈。正在运行的程序：**代码段 + 数据段 + BSS 段 + 堆 + 栈**。

如图所示为可执行应用程序**存储态**和**运行态**的结构对照图。一个正在运行的 C 程序占用的内存区域分为代码段、数据段（初始化数据）、BSS 段（未初始化数据）、堆和栈 5 部分

![[Pasted image 20230102191229.png]]

图上的堆箭头，指的是地址分配的方向。

## 内存管理

将应用程序加载到内存空间执行时，操作系统负责代码段、程序段和BSS段的加载，并在内存中为这些进行分配空间。栈也由操作系统管理，不需要程序员显示的管理；堆段需要程序员自己管理，显示的申请和释放。

### 各段说明

#### 代码段

代码段在内存中被映射为只读。它是由编译器在编译链接时自动计算的。通常是用来存放程序执行的指令。代码段输入静态内存分配。

#### 数据段

通常用来存放程序中已初始化的（非 0）全局变量和静态局部变量。数据段的起始位置由链接定位文件确认，大小在编译链接时自动分配。数据段属于静态内存分配

#### BSS段

通常用来存放程序中未初始化和初始化为 0的全局变量的一块内存区域，在程序载入时由内核清零。数据段属于静态内存分配

#### 堆

堆保存函数的内部动态分配（malloc或new的内存），是一种用来保存程序信息的数据结构

堆是先进先出的数据结构，堆的地址是向上增加的，即当堆上保存的数据越多，堆的地址越高。动态内存分配。---每次低位的地址先被读取？


注意：堆内存需要程序员手动管理内存，通常适用于较大的内存分配，如频繁的分配较小的内存，容易导致内存碎片化。



#### 栈

栈保存函数的局部变量（不包含static修饰的变量），参数以及返回值，是一种先进后出的数据结构

在调用函数或者过程后，系统会清除栈上保存的局部变量、函数调用信息以及其他信息


栈的另外一个重要特征是，它的地址空间 向下减少，即当栈上保存的数据越多，栈的地址越低。静态内存分配

注意，由于栈的空间通常比较小，一般 linux 程序只有几 M，故局部变量，函数入参应该避免出现超大栈内存使用，比如超大结构体，数组等，避免出现 stack overflow



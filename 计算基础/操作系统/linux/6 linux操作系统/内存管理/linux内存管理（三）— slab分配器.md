
通俗的讲，slab 就是专门为某一模块预先一次性申请一定数量的内存备用，当这个模块想要使用内存的时候，就不再需要从系统中分配内存了（因为从系统中申请内存的时间开销相对来说比较大），而是直接从预申请的内存中拿出一部分来使用，这样就提高了这个模块的内存申请速度。


slab 要在合适的场合下使用才能发挥作用。使用 slab 通常需要满足以下两个条件：

第一条件是，当某一子系统需要频繁地申请和释放内存时，使用 slab 才会合理一些。如果某段程序中申请和释放内存的频率不高，就没必要预先申请一块很大的内存备用，然后再从这段私有空间中分配内存了。因为这样就意味着系统将会一次性损失过多内存，而由于内存请求的频率不高，也不会对系统性能有多大的提升。所以，对于频繁使用内存的程序来说，使用 slab 才有意义。

使用 slab 的另一个条件是，利用 slab 申请的内存必须是大小固定的。只有固定内存大小才有可能实现内存的高速申请和释放。



slab 分配器大致情况就是这样，那么Linux 内存管理当中为什么要引进slab分配器呢？

在解决小的内存碎片上，Linux 采用[伙伴算法](http://blog.csdn.net/wenqian1991/article/details/27968779)解决外部碎片的产生，但会因此产生内部碎片，基于此，Linux 内存管理采用了 slab allocation 机制：整理内存以便重复使用来避免常见的内部碎片问题。很显然 slab 机制是基于 buddy 短发的，前者是后者的细化。

重新说说slab 分配器的基本原理：按照预定固定的大小，将分配的内存分割成特定长度的块，以完全解决内存碎片问题。换句话说就是，将分配的内存分割成各种尺寸的块，并把相同尺寸的块分成组。另外分配到的内存不会释放，而是返回到对应的组，重复利用。


流式套接字(SOCK_STREAM)：一种面向连接的Socket，针对于面向连接的TCP 服务应用;
数据报式套接字(SOCK_DGRAM)：一种无连接的Socket，对应于无连接的UDP 服务应用。

  
流式套接字只能收发 TCP 协议的数据，数据报套接字只能收发 UDP 协议的数据，原始套接字可以收发内核没有处理的数据包。


从用户的角度来看，SOCK_STREAM、SOCK_DGRAM 这两类套接字似乎的确涵盖了TCP/IP 应用的全部，因为基于TCP/IP 的应用，从协议栈的层次上讲，在传输层的确只可能建立于TCP 或 UDP协议之上，而SOCK_STREAM、SOCK_DGRAM 又分别对应于TCP和UDP，所以几乎所有的应用都可以用这两类套接字实现。

但是，当我们面对如下问题时，SOCK_STREAM、SOCK_DGRAM 将显得这样无助： 
1. 怎样发送一个自定义的IP 包? 
2. 怎样发送一个ICMP 协议包? 
3. 怎样分析所有经过网络的包，而不管这样包是否是发给自己的? 
4. 怎样伪装本地的IP 地址?


 因为SOCK_STREAM（TCP）、SOCK_DGRAM （UDP）发送的数据报文经过网络协议栈需要进行封装处理：包括加UDP头（TCP头），加IP头等信息，最终发出去的报文并不是我们想要的IP报文/ICMP报文等，这里就需要采用一种方法来越过协议栈的自动封装处理，直接让我们指定 报文的信息（当然也包括IP等头部信息）。
 
 至于分析网络数据包，原始套接字是个很好的选择，他不仅可以获取到IP层的数据包，还可以获取到数据链路层的报文，而这部分信息可能是我们最需要的头部信息：源MAC、目的MAC、源IP、目的IP、源端口、目的端口等信息，如果我们需要统计经过网卡的数据包，则完全可以通过原始套接字在应用层很方便的获取到，另外一个好处就是应用层可以使用库函数、文件IO等进行操作，非常便利；当然这部分信息本来是在驱动等获取的，具体的获取方法是通过hook(钩子函数)来获取相应的报文，可以进行头部信息操作，也可以统计网卡的收发数据量，但是如果想记录并存储具体的报文内容信息，如报文发送源IP，目的IP等信息，那么在钩子函数里进行这种耗时的操作就很不明智了，而且驱动里进行IO操作不向应用层那么方便，因此并不推荐在驱动力进行耗时的操作。在网关设备中统计网卡的信息应该经常用到该套接字。




## 原始套接字 可以做什么？

    原始套接字编程和之前的UDP 编程差不多，无非就是创建一个套接字后，通过这个套接字接收数据或者发送数据。区别在于，原始套接字可以自行组装数据包(伪装本地 IP，本地 MAC)，可以接收本机网卡上所有的数据帧(数据包)。另外，必须在管理员权限下才能使用原始套接字。




## 混杂模式

  默认的情况下，我们接收数据，目的MAC是本地地址，才会接收。有时候我们想接收所有经过网卡的所有数据流，而不论其目的MAC是否是它，这时候我们需要设置网卡为混杂模式。
    网卡的混杂模式一般在网络管理员分析网络数据作为网络故障诊断手段时用到，同时这个模式也被网络黑客利用来作为网络数据窃听的入口。在 Linux 操作系统中设置网卡混杂模式时需要管理员权限。在 Windows 操作系统和 Linux 操作系统中都有使用混杂模式的抓包工具，比如著名的开源软件 Wireshark。
    通过命令给 Linux 网卡设置混杂模式(需要管理员权限)

